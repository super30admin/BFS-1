# -*- coding: utf-8 -*-
"""BFS-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KTwAu84rf7qKJuQE1VWJbsPw4QlsMHTy

Level Order Traverssal in a Binary Tree

DFS
"""

class Node:
 
    def __init__(self, val):
 
        self.left = None
        self.right = None
        self.val = val
    def insert(self, val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = Node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val
    
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        global result
        result = []
        self.dfs(root,0)
        return result
    def dfs(self,root,level):
        if root is None:
            return
        if len(result) <= level:
            result.append([])
        result[level].append(root.val)
        self.dfs(root.left,level+1)
        self.dfs(root.right,level+1)
root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(6)
root.insert(19)
root.insert(31)
root.insert(42)
levelOrder = root.levelOrder(root)
print(levelOrder)

"""BFS"""

class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
       

class Node:
 
    def __init__(self, val):
 
        self.left = None
        self.right = None
        self.val = val
    def insert(self, val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = Node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val
    
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if root is None:
            return
        q = []
        q.append(root)
        result = []
        while len(q) != 0:
            length = len(q)
            list = []
            for i in range(length):
                node = q.pop(0)
                list.append(node.val)
                if node.left is not None:
                    q.append(node.left)
                if node.right is not None:
                    q.append(node.right)
            result.append(list)
        return result
        
root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(6)
root.insert(19)
root.insert(31)
root.insert(42)
levelOrder = root.levelOrder(root)
print(levelOrder)

"""Right View of a Binary Tree

BFS
"""

class Node:
 
    def __init__(self, val):
 
        self.left = None
        self.right = None
        self.val = val
    def insert(self, val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = Node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val
    
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root is None:
            return
        queue = []
        queue.append(root)
        right_view = []
        while len(queue) != 0:
            level_length = len(queue)
            right_view.append(queue[-1].val)
            for i in range(level_length):
                node = queue.pop(0)
                if node.left is not None:
                    queue.append(node.left)
                if node.right is not None:
                    queue.append(node.right)
        return right_view
        
root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(6)
root.insert(19)
root.insert(31)
root.insert(42)
rightView = root.rightSideView(root)
print(rightView)

"""DFS"""

class Node:
 
    def __init__(self, val):
 
        self.left = None
        self.right = None
        self.val = val
    def insert(self, val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = Node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val
    
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root is None:
            return []
        global rightView
        rightView = []
        self.dfs(root,0)
        return rightView
    def dfs(self,root,level):
      if root is None:
        return
      if len(rightView) == level :
        rightView.append(root.val)
      self.dfs(root.right,level+1)
      self.dfs(root.left,level+1)
        
        
root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(6)
root.insert(19)
root.insert(31)
root.insert(42)
rightView = root.rightSideView(root)
print(rightView)

"""Cousins in Tree

BFS
"""

class Node:
 
    def __init__(self, val):
 
        self.left = None
        self.right = None
        self.val = val
    def insert(self, val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = Node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val
    
    def isCousins(self, root, x, y):
        if root is None:
            return
        queue = []
        queue.append(root)
        while len(queue) != 0:
            level_length = len(queue)
            x_found = False
            y_found = False
            for i in range(level_length): 
                node = queue.pop(0)
                if node.val == x:
                    x_found = True
                if node.val == y:
                    y_found = True
                if (node.left is not None and node.right is not None) and ((node.left.val == x and node.right.val == y) or (node.left.val == y and node.right.val == x )):
                    return False
                if node.left is not None:
                    queue.append(node.left)
                if node.right is not None:
                    queue.append(node.right)
            if x_found == True and y_found == True:
                return True
            if x_found or y_found:
                return False
        return False
            
        
        
root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(6)
root.insert(19)
root.insert(31)
root.insert(42)
cousins = root.isCousins(root,19,10)
print(cousins)

"""DFS"""

class Node:
    
    def __init__(self, val):
 
        self.left = None
        self.right = None
        self.val = val
    def insert(self, val):
        if self.val:
            if val < self.val:
                if self.left is None:
                    self.left = Node(val)
                else:
                    self.left.insert(val)
            elif val > self.val:
                if self.right is None:
                    self.right = Node(val)
                else:
                    self.right.insert(val)
        else:
            self.val = val
    
    def isCousins(self, root, x, y):
        if root is None:
          return
        global parent_x
        global parent_y
        global level_x
        global level_y
        parent_x, parent_y = [], []
        level_x, level_y = [], []
        self.dfs(root, 0, root, x, y)
        return (parent_x[0] != parent_y[0]) and (level_x[0] == level_y[0])
    def dfs(self,root, level, parent,x ,y):
      if root is None:
        return
      if root.val == x:
        parent_x.append(parent.val)
        level_x.append(level)
        
      if root.val == y:
        parent_y.append(parent.val)
        level_y.append(level)

       
      self.dfs(root.left,level+1,root,x,y)
      self.dfs(root.right,level+1,root,x,y)


      
            
       
        
root = Node(27)
root.insert(14)
root.insert(35)
root.insert(10)
root.insert(6)
root.insert(19)
root.insert(31)
root.insert(42)
cousins = root.isCousins(root,19,14)
print(parent_x, parent_y, level_x, level_y) 
print(cousins)